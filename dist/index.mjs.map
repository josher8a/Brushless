{"version":3,"sources":["../src/Brushless.bs.js","../src/Brushless.bs.ts","../src/index.ts"],"sourcesContent":["// Generated by ReScript, PLEASE EDIT WITH CARE\n'use strict';\n\n\nfunction getOr(value, $$default) {\n  if (value === undefined) {\n    return $$default;\n  } else {\n    return value;\n  }\n}\n\nfunction equal(a, b, eq) {\n  if (a === undefined) {\n    if (b === undefined) {\n      return true;\n    } else {\n      return false;\n    }\n  } else if (b === undefined) {\n    return false;\n  } else {\n    return eq(a, b);\n  }\n}\n\nlet Undefinable = {\n  getOr: getOr,\n  equal: equal\n};\n\nfunction make(name) {\n  return {\n    TAG: \"AttributeName\",\n    name: name\n  };\n}\n\nfunction toString(name) {\n  let name$1 = name.name;\n  if (name$1.includes(\" \") || name$1.includes(\".\")) {\n    throw new Error(\"InvalidName\");\n  }\n  return \"#\" + name$1.replaceAll(\"-\", \"_\");\n}\n\nlet AttributeName = {\n  make: make,\n  toString: toString\n};\n\nfunction make$1(x) {\n  return {\n    TAG: \"AttributeValue\",\n    value: x.value,\n    alias: x.alias\n  };\n}\n\nfunction toString$1(value) {\n  return \":\" + value.alias;\n}\n\nlet AttributeValue = {\n  make: make$1,\n  toString: toString$1\n};\n\nfunction splitWhen(str, predicate) {\n  let _index = 0;\n  while (true) {\n    let index = _index;\n    let char = str[index];\n    if (char === undefined) {\n      return [\n        str,\n        \"\",\n        \"\"\n      ];\n    }\n    if (predicate(char)) {\n      return [\n        str.substring(0, index),\n        str.substring(index, index + 1 | 0),\n        str.substring(index + 1 | 0)\n      ];\n    }\n    _index = index + 1 | 0;\n    continue;\n  };\n}\n\nfunction fromString(str) {\n  let parse = (_str, _state, _accOpt) => {\n    while (true) {\n      let accOpt = _accOpt;\n      let state = _state;\n      let str = _str;\n      let acc = accOpt !== undefined ? accOpt : [];\n      let match = splitWhen(str, char => {\n        if (char === \"[\") {\n          return true;\n        } else {\n          return char === \".\";\n        }\n      });\n      let rest = match[2];\n      let name = match[0];\n      if (state === \"Name\") {\n        if (name === \"\") {\n          throw new Error(\"InvalidPath\");\n        }\n        acc.push({\n          TAG: \"AttributeName\",\n          name: name\n        });\n      } else if (name !== \"\") {\n        throw new Error(\"InvalidPath\");\n      }\n      switch (match[1]) {\n        case \"\" :\n          if (rest === \"\") {\n            return acc;\n          }\n          throw new Error(\"InvalidPath\");\n        case \".\" :\n          _accOpt = acc;\n          _state = \"Name\";\n          _str = rest;\n          continue;\n        case \"[\" :\n          let match$1 = splitWhen(rest, char => char === \"]\");\n          if (match$1[1] === \"]\") {\n            acc.push({\n              TAG: \"ListIndex\",\n              index: parseIndex(match$1[0])\n            });\n            _accOpt = acc;\n            _state = \"Index\";\n            _str = match$1[2];\n            continue;\n          }\n          throw new Error(\"InvalidPath\");\n        default:\n          throw new Error(\"InvalidPath\");\n      }\n    };\n  };\n  let parseIndex = index => {\n    let x = parseInt(index);\n    if (isFinite(x) && x >= 0 && index.length === x.toString().length) {\n      return x | 0;\n    }\n    throw new Error(\"InvalidIndex: \" + index);\n  };\n  let acc = [];\n  let match = parse(str, \"Name\", acc).shift();\n  if (match !== undefined) {\n    if (match.TAG === \"AttributeName\") {\n      return {\n        TAG: \"AttributePath\",\n        name: match.name,\n        subpath: acc\n      };\n    }\n    throw new Error(\"InvalidPath\");\n  }\n  throw new Error(\"InvalidPath\");\n}\n\nfunction toString$2(param) {\n  return param.subpath.reduce((acc, subs) => {\n    if (subs.TAG === \"AttributeName\") {\n      return acc + \".\" + toString({\n        TAG: \"AttributeName\",\n        name: subs.name\n      });\n    } else {\n      return acc + \"[\" + String(subs.index) + \"]\";\n    }\n  }, toString({\n    TAG: \"AttributeName\",\n    name: param.name\n  }));\n}\n\nlet AttributePath = {\n  fromString: fromString,\n  toString: toString$2\n};\n\nfunction make$2() {\n  return {\n    names: undefined,\n    values: undefined\n  };\n}\n\nfunction isValueEqual(a, b) {\n  return [\n    equal(a.S, b.S, (x, y) => x === y),\n    equal(a.N, b.N, (x, y) => x === y),\n    equal(a.NULL, b.NULL, (x, y) => x === y),\n    equal(a.BOOL, b.BOOL, (x, y) => x === y),\n    equal(a.SS, b.SS, (x, y) => x.every(v => y.includes(v))),\n    equal(a.NS, b.NS, (x, y) => x.every(v => y.includes(v))),\n    equal(a.L, b.L, (x, y) => x.every((v, i) => {\n      let y$1 = y[i];\n      if (y$1 !== undefined) {\n        return isValueEqual(v, y$1);\n      } else {\n        return false;\n      }\n    })),\n    equal(a.M, b.M, (x, y) => {\n      let keys = Object.entries(x);\n      if (keys.length === Object.keys(y).length) {\n        return keys.every(param => {\n          let y$1 = y[param[0]];\n          if (y$1 !== undefined) {\n            return isValueEqual(param[1], y$1);\n          } else {\n            return false;\n          }\n        });\n      } else {\n        return false;\n      }\n    })\n  ].some(x => x);\n}\n\nfunction addValue(register, _element) {\n  while (true) {\n    let element = _element;\n    let alias = element.alias;\n    let value = element.value;\n    let key = toString$1({\n      TAG: \"AttributeValue\",\n      value: value,\n      alias: alias\n    });\n    let dict = getOr(register.values, {});\n    let exist = dict[key];\n    if (exist !== undefined && exist !== value && !isValueEqual(exist, value)) {\n      _element = {\n        TAG: \"AttributeValue\",\n        value: value,\n        alias: alias + \"_\"\n      };\n      continue;\n    }\n    dict[key] = value;\n    register.values = dict;\n    return element;\n  };\n}\n\nfunction addName(register, element) {\n  let name = element.name;\n  let dict = getOr(register.names, {});\n  dict[toString({\n        TAG: \"AttributeName\",\n        name: name\n      })] = name;\n  register.names = dict;\n  return element;\n}\n\nfunction addPath(register, element) {\n  let name = element.name;\n  let dict = getOr(register.names, {});\n  dict[toString({\n        TAG: \"AttributeName\",\n        name: name\n      })] = name;\n  element.subpath.forEach(sub => {\n    if (sub.TAG !== \"AttributeName\") {\n      return;\n    }\n    let name = sub.name;\n    dict[toString({\n          TAG: \"AttributeName\",\n          name: name\n        })] = name;\n  });\n  register.names = dict;\n  return element;\n}\n\nlet Register = {\n  make: make$2,\n  addValue: addValue,\n  addName: addName,\n  addPath: addPath\n};\n\nfunction toString$3(identifier, register) {\n  if (identifier.TAG === \"AttributePath\") {\n    return toString$2(addPath(register, {\n      TAG: \"AttributePath\",\n      name: identifier.name,\n      subpath: identifier.subpath\n    }));\n  } else {\n    return toString(addName(register, {\n      TAG: \"AttributeName\",\n      name: identifier.name\n    }));\n  }\n}\n\nlet Identifier = {\n  toString: toString$3\n};\n\nfunction equals(lhs, rhs) {\n  return {\n    TAG: \"Comparison\",\n    lhs: lhs,\n    comparator: \"=\",\n    rhs: rhs\n  };\n}\n\nfunction notEquals(lhs, rhs) {\n  return {\n    TAG: \"Comparison\",\n    lhs: lhs,\n    comparator: \"<>\",\n    rhs: rhs\n  };\n}\n\nfunction lessThan(lhs, rhs) {\n  return {\n    TAG: \"Comparison\",\n    lhs: lhs,\n    comparator: \"<\",\n    rhs: rhs\n  };\n}\n\nfunction lessThanOrEqualTo(lhs, rhs) {\n  return {\n    TAG: \"Comparison\",\n    lhs: lhs,\n    comparator: \"<=\",\n    rhs: rhs\n  };\n}\n\nfunction greaterThan(lhs, rhs) {\n  return {\n    TAG: \"Comparison\",\n    lhs: lhs,\n    comparator: \">\",\n    rhs: rhs\n  };\n}\n\nfunction greaterThanOrEqualTo(lhs, rhs) {\n  return {\n    TAG: \"Comparison\",\n    lhs: lhs,\n    comparator: \">=\",\n    rhs: rhs\n  };\n}\n\nfunction between(operand, limits) {\n  return {\n    TAG: \"Between\",\n    operand: operand,\n    limits: limits\n  };\n}\n\nfunction inList(operand, list) {\n  return {\n    TAG: \"In\",\n    operand: operand,\n    list: list\n  };\n}\n\nfunction attributeExists(identifier) {\n  return {\n    TAG: \"AttributeExists\",\n    identifier: identifier\n  };\n}\n\nfunction attributeNotExists(identifier) {\n  return {\n    TAG: \"AttributeNotExists\",\n    identifier: identifier\n  };\n}\n\nfunction attributeType(identifier, operand) {\n  return {\n    TAG: \"AttributeType\",\n    identifier: identifier,\n    operand: operand\n  };\n}\n\nfunction beginsWith(identifier, operand) {\n  return {\n    TAG: \"BeginsWith\",\n    identifier: identifier,\n    operand: operand\n  };\n}\n\nfunction contains(identifier, operand) {\n  return {\n    TAG: \"Contains\",\n    identifier: identifier,\n    operand: operand\n  };\n}\n\nfunction toContains(identifier, operand) {\n  return {\n    TAG: \"ToContains\",\n    identifier: identifier,\n    operand: operand\n  };\n}\n\nfunction and(lhs, rhs) {\n  return {\n    TAG: \"And\",\n    lhs: lhs,\n    rhs: rhs\n  };\n}\n\nfunction or(lhs, rhs) {\n  return {\n    TAG: \"Or\",\n    lhs: lhs,\n    rhs: rhs\n  };\n}\n\nfunction not(condition) {\n  return {\n    TAG: \"Not\",\n    condition: condition\n  };\n}\n\nfunction size(operand) {\n  return {\n    TAG: \"Size\",\n    operand: operand\n  };\n}\n\nlet Maker = {\n  equals: equals,\n  notEquals: notEquals,\n  lessThan: lessThan,\n  lessThanOrEqualTo: lessThanOrEqualTo,\n  greaterThan: greaterThan,\n  greaterThanOrEqualTo: greaterThanOrEqualTo,\n  between: between,\n  inList: inList,\n  attributeExists: attributeExists,\n  attributeNotExists: attributeNotExists,\n  attributeType: attributeType,\n  beginsWith: beginsWith,\n  contains: contains,\n  toContains: toContains,\n  and: and,\n  or: or,\n  not: not,\n  size: size\n};\n\nlet Overload = {\n  $amp$amp: and,\n  $pipe$pipe: or,\n  $bang: not,\n  $eq$eq: equals,\n  $bang$eq: notEquals,\n  $less: lessThan,\n  $less$eq: lessThanOrEqualTo,\n  $great: greaterThan,\n  $great$eq: greaterThanOrEqualTo\n};\n\nfunction build(condition, register) {\n  let toString$4 = condition => {\n    switch (condition.TAG) {\n      case \"Comparison\" :\n        return opString(condition.lhs) + \" \" + condition.comparator + \" \" + opString(condition.rhs);\n      case \"Between\" :\n        let limits = condition.limits;\n        return opString(condition.operand) + \" BETWEEN \" + opString(limits.lower) + \" AND \" + opString(limits.upper);\n      case \"In\" :\n        return opString(condition.operand) + \" IN (\" + condition.list.map(opString).join(\", \") + \")\";\n      case \"And\" :\n        return \"(\" + toString$4(condition.lhs) + \") AND (\" + toString$4(condition.rhs) + \")\";\n      case \"Or\" :\n        return \"(\" + toString$4(condition.lhs) + \") OR (\" + toString$4(condition.rhs) + \")\";\n      case \"Not\" :\n        return \"NOT (\" + toString$4(condition.condition) + \")\";\n      case \"AttributeExists\" :\n        return \"attribute_exists(\" + toString$3(condition.identifier, register) + \")\";\n      case \"AttributeNotExists\" :\n        return \"attribute_not_exists(\" + toString$3(condition.identifier, register) + \")\";\n      case \"AttributeType\" :\n        return \"attribute_type(\" + toString$3(condition.identifier, register) + \", \" + opString(condition.operand) + \")\";\n      case \"BeginsWith\" :\n        return \"begins_with(\" + toString$3(condition.identifier, register) + \", \" + opString(condition.operand) + \")\";\n      case \"Contains\" :\n        return \"contains(\" + toString$3(condition.identifier, register) + \", \" + opString(condition.operand) + \")\";\n      case \"ToContains\" :\n        return \"contains(\" + opString(condition.operand) + \", \" + toString$3(condition.identifier, register) + \")\";\n    }\n  };\n  let opString = operand => {\n    switch (operand.TAG) {\n      case \"AttributePath\" :\n        return toString$2(addPath(register, {\n          TAG: \"AttributePath\",\n          name: operand.name,\n          subpath: operand.subpath\n        }));\n      case \"AttributeName\" :\n        return toString(addName(register, {\n          TAG: \"AttributeName\",\n          name: operand.name\n        }));\n      case \"AttributeValue\" :\n        return toString$1(addValue(register, {\n          TAG: \"AttributeValue\",\n          value: operand.value,\n          alias: operand.alias\n        }));\n      case \"Size\" :\n        return \"size(\" + opString(operand.operand) + \")\";\n    }\n  };\n  return toString$4(condition);\n}\n\nlet Condition = {\n  Maker: Maker,\n  equals: equals,\n  notEquals: notEquals,\n  lessThan: lessThan,\n  lessThanOrEqualTo: lessThanOrEqualTo,\n  greaterThan: greaterThan,\n  greaterThanOrEqualTo: greaterThanOrEqualTo,\n  between: between,\n  inList: inList,\n  attributeExists: attributeExists,\n  attributeNotExists: attributeNotExists,\n  attributeType: attributeType,\n  beginsWith: beginsWith,\n  contains: contains,\n  toContains: toContains,\n  and: and,\n  or: or,\n  not: not,\n  size: size,\n  Overload: Overload,\n  build: build\n};\n\nfunction build$1(projection, register) {\n  return projection.map(__x => toString$3(__x, register)).join(\", \");\n}\n\nlet Projection = {\n  build: build$1\n};\n\nfunction equals$1(name, value) {\n  return {\n    TAG: \"Comparison\",\n    name: name,\n    comparator: \"=\",\n    value: value\n  };\n}\n\nfunction notEquals$1(name, value) {\n  return {\n    TAG: \"Comparison\",\n    name: name,\n    comparator: \"<>\",\n    value: value\n  };\n}\n\nfunction lessThan$1(name, value) {\n  return {\n    TAG: \"Comparison\",\n    name: name,\n    comparator: \"<\",\n    value: value\n  };\n}\n\nfunction lessThanOrEqualTo$1(name, value) {\n  return {\n    TAG: \"Comparison\",\n    name: name,\n    comparator: \"<=\",\n    value: value\n  };\n}\n\nfunction greaterThan$1(name, value) {\n  return {\n    TAG: \"Comparison\",\n    name: name,\n    comparator: \">\",\n    value: value\n  };\n}\n\nfunction greaterThanOrEqualTo$1(name, value) {\n  return {\n    TAG: \"Comparison\",\n    name: name,\n    comparator: \">=\",\n    value: value\n  };\n}\n\nfunction between$1(name, limits) {\n  return {\n    TAG: \"Between\",\n    name: name,\n    limits: limits\n  };\n}\n\nfunction beginsWith$1(name, value) {\n  return {\n    TAG: \"BeginsWith\",\n    name: name,\n    value: value\n  };\n}\n\nlet Maker$1 = {\n  equals: equals$1,\n  notEquals: notEquals$1,\n  lessThan: lessThan$1,\n  lessThanOrEqualTo: lessThanOrEqualTo$1,\n  greaterThan: greaterThan$1,\n  greaterThanOrEqualTo: greaterThanOrEqualTo$1,\n  between: between$1,\n  beginsWith: beginsWith$1,\n  any: \"Any\"\n};\n\nfunction skConditionToString(skCondition, register) {\n  if (typeof skCondition !== \"object\") {\n    return \"\";\n  }\n  switch (skCondition.TAG) {\n    case \"Comparison\" :\n      return \" AND \" + toString(addName(register, skCondition.name)) + \" \" + skCondition.comparator + \" \" + toString$1(addValue(register, skCondition.value));\n    case \"Between\" :\n      let limits = skCondition.limits;\n      return \" AND \" + toString(addName(register, skCondition.name)) + \" BETWEEN \" + toString$1(addValue(register, limits.lower)) + \" AND \" + toString$1(addValue(register, limits.upper));\n    case \"BeginsWith\" :\n      return \" AND begins_with(\" + toString(addName(register, skCondition.name)) + \", \" + toString$1(addValue(register, skCondition.value)) + \")\";\n  }\n}\n\nfunction build$2(keyCondition, register) {\n  return toString(addName(register, keyCondition.pk.name)) + \" = \" + toString$1(addValue(register, keyCondition.pk.value)) + skConditionToString(keyCondition.sk, register);\n}\n\nlet KeyCondition = {\n  Maker: Maker$1,\n  equals: equals$1,\n  notEquals: notEquals$1,\n  lessThan: lessThan$1,\n  lessThanOrEqualTo: lessThanOrEqualTo$1,\n  greaterThan: greaterThan$1,\n  greaterThanOrEqualTo: greaterThanOrEqualTo$1,\n  between: between$1,\n  beginsWith: beginsWith$1,\n  any: \"Any\",\n  build: build$2\n};\n\nfunction listAppend(identifier, operand) {\n  return {\n    TAG: \"ListAppend\",\n    identifier: identifier,\n    operand: operand\n  };\n}\n\nfunction ifNotExists(identifier, operand) {\n  return {\n    TAG: \"IfNotExists\",\n    identifier: identifier,\n    operand: operand\n  };\n}\n\nfunction sum(lhs, rhs) {\n  return {\n    TAG: \"Sum\",\n    lhs: lhs,\n    rhs: rhs\n  };\n}\n\nfunction sub(lhs, rhs) {\n  return {\n    TAG: \"Sub\",\n    lhs: lhs,\n    rhs: rhs\n  };\n}\n\nlet Maker$2 = {\n  listAppend: listAppend,\n  ifNotExists: ifNotExists,\n  sum: sum,\n  sub: sub\n};\n\nfunction operandToString(operand, register) {\n  switch (operand.TAG) {\n    case \"AttributePath\" :\n      return toString$2(addPath(register, {\n        TAG: \"AttributePath\",\n        name: operand.name,\n        subpath: operand.subpath\n      }));\n    case \"AttributeName\" :\n      return toString(addName(register, {\n        TAG: \"AttributeName\",\n        name: operand.name\n      }));\n    case \"AttributeValue\" :\n      return toString$1(addValue(register, {\n        TAG: \"AttributeValue\",\n        value: operand.value,\n        alias: operand.alias\n      }));\n    case \"ListAppend\" :\n      return \"list_append(\" + operandToString(operand.identifier, register) + \", \" + operandToString(operand.operand, register) + \")\";\n    case \"IfNotExists\" :\n      return \"if_not_exists(\" + operandToString(operand.identifier, register) + \", \" + operandToString(operand.operand, register) + \")\";\n    case \"Sum\" :\n      return operandToString(operand.lhs, register) + \" + \" + operandToString(operand.rhs, register);\n    case \"Sub\" :\n      return operandToString(operand.lhs, register) + \" - \" + operandToString(operand.rhs, register);\n  }\n}\n\nfunction appendIfNotEmpty(acc, arr, tag, fn) {\n  if (arr !== undefined && arr.length > 0) {\n    return acc + tag + \" \" + arr.map(fn).join(\", \") + \" \";\n  } else {\n    return acc;\n  }\n}\n\nfunction build$3(update, register) {\n  return appendIfNotEmpty(appendIfNotEmpty(appendIfNotEmpty(appendIfNotEmpty(\"\", update.add, \"ADD\", param => toString$3(param[0], register) + \" \" + toString$1(addValue(register, param[1]))), update.delete, \"DELETE\", param => toString$3(param[0], register) + \" \" + toString$1(addValue(register, param[1]))), update.set, \"SET\", param => toString$3(param[0], register) + \" = \" + operandToString(param[1], register)), update.remove, \"REMOVE\", __x => toString$3(__x, register)).trim();\n}\n\nlet Update = {\n  Maker: Maker$2,\n  listAppend: listAppend,\n  ifNotExists: ifNotExists,\n  sum: sum,\n  sub: sub,\n  build: build$3\n};\n\nlet U = {\n  Maker: Maker$2,\n  listAppend: listAppend,\n  ifNotExists: ifNotExists,\n  sum: sum,\n  sub: sub,\n  build: build$3\n};\n\nlet C = {\n  Maker: Maker,\n  equals: equals,\n  notEquals: notEquals,\n  lessThan: lessThan,\n  lessThanOrEqualTo: lessThanOrEqualTo,\n  greaterThan: greaterThan,\n  greaterThanOrEqualTo: greaterThanOrEqualTo,\n  between: between,\n  inList: inList,\n  attributeExists: attributeExists,\n  attributeNotExists: attributeNotExists,\n  attributeType: attributeType,\n  beginsWith: beginsWith,\n  contains: contains,\n  toContains: toContains,\n  and: and,\n  or: or,\n  not: not,\n  size: size,\n  Overload: Overload,\n  build: build\n};\n\nlet K = {\n  Maker: Maker$1,\n  equals: equals$1,\n  notEquals: notEquals$1,\n  lessThan: lessThan$1,\n  lessThanOrEqualTo: lessThanOrEqualTo$1,\n  greaterThan: greaterThan$1,\n  greaterThanOrEqualTo: greaterThanOrEqualTo$1,\n  between: between$1,\n  beginsWith: beginsWith$1,\n  any: \"Any\",\n  build: build$2\n};\n\nlet P = {\n  build: build$1\n};\n\nexports.Undefinable = Undefinable;\nexports.AttributeName = AttributeName;\nexports.AttributeValue = AttributeValue;\nexports.AttributePath = AttributePath;\nexports.Register = Register;\nexports.Identifier = Identifier;\nexports.Condition = Condition;\nexports.Projection = Projection;\nexports.KeyCondition = KeyCondition;\nexports.Update = Update;\nexports.U = U;\nexports.C = C;\nexports.K = K;\nexports.P = P;\n/* No side effect */\n","/* TypeScript file generated from Brushless.res by genType. */\n\n/* eslint-disable */\n/* tslint:disable */\n\nconst BrushlessJS = require('./Brushless.bs.js');\n\nimport type {AttributeValue as $$attributeValue} from './external';\n\nexport type attributeValue = $$attributeValue;\n\nexport type Undefinable_t<a> = undefined | a;\n\nexport type AttributeName_t = \n    { TAG: \"AttributeName\"; readonly name: string };\n\nexport type AttributeValue_t = \n    { TAG: \"AttributeValue\"; readonly value: attributeValue; readonly alias: string };\n\nexport type AttributeValue_from<a> = { readonly value: a; readonly alias: string };\n\nexport type AttributePath_sub = \n    { TAG: \"AttributeName\"; readonly name: string }\n  | { TAG: \"ListIndex\"; readonly index: number };\n\nexport type AttributePath_t = \n    { TAG: \"AttributePath\"; readonly name: string; readonly subpath: AttributePath_sub[] };\n\nexport type AttributePath_parseState = \"Name\" | \"Index\";\n\nexport type Register_t = { names: Undefinable_t<{[id: string]: string}>; values: Undefinable_t<{[id: string]: attributeValue}> };\n\nexport abstract class Register_uint8Array { protected opaque!: any }; /* simulate opaque types */\n\nexport abstract class Register_attributeValue_ { protected opaque!: any }; /* simulate opaque types */\n\nexport type comparator = \"=\" | \"<>\" | \"<\" | \"<=\" | \">\" | \">=\";\n\nexport type Identifier_t = \n    { TAG: \"AttributePath\"; readonly name: string; readonly subpath: AttributePath_sub[] }\n  | { TAG: \"AttributeName\"; readonly name: string };\n\nexport type Condition_operand = \n    { TAG: \"AttributePath\"; readonly name: string; readonly subpath: AttributePath_sub[] }\n  | { TAG: \"AttributeName\"; readonly name: string }\n  | { TAG: \"AttributeValue\"; readonly value: attributeValue; readonly alias: string }\n  | { TAG: \"Size\"; readonly operand: Condition_operand };\n\nexport type Condition_limits = { readonly lower: Condition_operand; readonly upper: Condition_operand };\n\nexport type Condition_condition = \n    { TAG: \"Comparison\"; readonly lhs: Condition_operand; readonly comparator: comparator; readonly rhs: Condition_operand }\n  | { TAG: \"Between\"; readonly operand: Condition_operand; readonly limits: Condition_limits }\n  | { TAG: \"In\"; readonly operand: Condition_operand; readonly list: Condition_operand[] }\n  | { TAG: \"And\"; readonly lhs: Condition_condition; readonly rhs: Condition_condition }\n  | { TAG: \"Or\"; readonly lhs: Condition_condition; readonly rhs: Condition_condition }\n  | { TAG: \"Not\"; readonly condition: Condition_condition }\n  | { TAG: \"AttributeExists\"; readonly identifier: Identifier_t }\n  | { TAG: \"AttributeNotExists\"; readonly identifier: Identifier_t }\n  | { TAG: \"AttributeType\"; readonly identifier: Identifier_t; readonly operand: Condition_operand }\n  | { TAG: \"BeginsWith\"; readonly identifier: Identifier_t; readonly operand: Condition_operand }\n  | { TAG: \"Contains\"; readonly identifier: Identifier_t; readonly operand: Condition_operand }\n  | { TAG: \"ToContains\"; readonly identifier: Identifier_t; readonly operand: Condition_operand };\n\nexport type Projection_projection = Identifier_t[];\n\nexport type KeyCondition_pkCond = { readonly name: AttributeName_t; readonly value: AttributeValue_t };\n\nexport type KeyCondition_limits = { readonly lower: AttributeValue_t; readonly upper: AttributeValue_t };\n\nexport type KeyCondition_skCondition = \n    \"Any\"\n  | { TAG: \"Comparison\"; readonly name: AttributeName_t; readonly comparator: comparator; readonly value: AttributeValue_t }\n  | { TAG: \"Between\"; readonly name: AttributeName_t; readonly limits: KeyCondition_limits }\n  | { TAG: \"BeginsWith\"; readonly name: AttributeName_t; readonly value: AttributeValue_t };\n\nexport type KeyCondition_keyCondition = { readonly pk: KeyCondition_pkCond; readonly sk: KeyCondition_skCondition };\n\nexport type Update_operand = \n    { TAG: \"AttributePath\"; readonly name: string; readonly subpath: AttributePath_sub[] }\n  | { TAG: \"AttributeName\"; readonly name: string }\n  | { TAG: \"AttributeValue\"; readonly value: attributeValue; readonly alias: string }\n  | { TAG: \"ListAppend\"; readonly identifier: Update_operand; readonly operand: Update_operand }\n  | { TAG: \"IfNotExists\"; readonly identifier: Update_operand; readonly operand: Update_operand }\n  | { TAG: \"Sum\"; readonly lhs: Update_operand; readonly rhs: Update_operand }\n  | { TAG: \"Sub\"; readonly lhs: Update_operand; readonly rhs: Update_operand };\n\nexport type Update_update = {\n  readonly set?: Array<[Identifier_t, Update_operand]>; \n  readonly remove?: Identifier_t[]; \n  readonly add?: Array<[Identifier_t, AttributeValue_t]>; \n  readonly delete?: Array<[Identifier_t, AttributeValue_t]>\n};\n\nexport type U_operand = \n    { TAG: \"AttributePath\"; readonly name: string; readonly subpath: AttributePath_sub[] }\n  | { TAG: \"AttributeName\"; readonly name: string }\n  | { TAG: \"AttributeValue\"; readonly value: attributeValue; readonly alias: string }\n  | { TAG: \"ListAppend\"; readonly identifier: U_operand; readonly operand: U_operand }\n  | { TAG: \"IfNotExists\"; readonly identifier: U_operand; readonly operand: U_operand }\n  | { TAG: \"Sum\"; readonly lhs: U_operand; readonly rhs: U_operand }\n  | { TAG: \"Sub\"; readonly lhs: U_operand; readonly rhs: U_operand };\n\nexport type U_update = {\n  readonly set?: Array<[Identifier_t, U_operand]>; \n  readonly remove?: Identifier_t[]; \n  readonly add?: Array<[Identifier_t, AttributeValue_t]>; \n  readonly delete?: Array<[Identifier_t, AttributeValue_t]>\n};\n\nexport type C_operand = \n    { TAG: \"AttributePath\"; readonly name: string; readonly subpath: AttributePath_sub[] }\n  | { TAG: \"AttributeName\"; readonly name: string }\n  | { TAG: \"AttributeValue\"; readonly value: attributeValue; readonly alias: string }\n  | { TAG: \"Size\"; readonly operand: C_operand };\n\nexport type C_limits = { readonly lower: C_operand; readonly upper: C_operand };\n\nexport type C_condition = \n    { TAG: \"Comparison\"; readonly lhs: C_operand; readonly comparator: comparator; readonly rhs: C_operand }\n  | { TAG: \"Between\"; readonly operand: C_operand; readonly limits: C_limits }\n  | { TAG: \"In\"; readonly operand: C_operand; readonly list: C_operand[] }\n  | { TAG: \"And\"; readonly lhs: C_condition; readonly rhs: C_condition }\n  | { TAG: \"Or\"; readonly lhs: C_condition; readonly rhs: C_condition }\n  | { TAG: \"Not\"; readonly condition: C_condition }\n  | { TAG: \"AttributeExists\"; readonly identifier: Identifier_t }\n  | { TAG: \"AttributeNotExists\"; readonly identifier: Identifier_t }\n  | { TAG: \"AttributeType\"; readonly identifier: Identifier_t; readonly operand: C_operand }\n  | { TAG: \"BeginsWith\"; readonly identifier: Identifier_t; readonly operand: C_operand }\n  | { TAG: \"Contains\"; readonly identifier: Identifier_t; readonly operand: C_operand }\n  | { TAG: \"ToContains\"; readonly identifier: Identifier_t; readonly operand: C_operand };\n\nexport type K_pkCond = { readonly name: AttributeName_t; readonly value: AttributeValue_t };\n\nexport type K_limits = { readonly lower: AttributeValue_t; readonly upper: AttributeValue_t };\n\nexport type K_skCondition = \n    \"Any\"\n  | { TAG: \"Comparison\"; readonly name: AttributeName_t; readonly comparator: comparator; readonly value: AttributeValue_t }\n  | { TAG: \"Between\"; readonly name: AttributeName_t; readonly limits: K_limits }\n  | { TAG: \"BeginsWith\"; readonly name: AttributeName_t; readonly value: AttributeValue_t };\n\nexport type K_keyCondition = { readonly pk: K_pkCond; readonly sk: K_skCondition };\n\nexport type P_projection = Identifier_t[];\n\nexport const AttributeName_make: (name:string) => AttributeName_t = BrushlessJS.AttributeName.make as any;\n\nexport const AttributeName_toString: (name:AttributeName_t) => string = BrushlessJS.AttributeName.toString as any;\n\nexport const AttributeValue_make: (x:AttributeValue_from<attributeValue>) => AttributeValue_t = BrushlessJS.AttributeValue.make as any;\n\nexport const AttributeValue_toString: (value:AttributeValue_t) => string = BrushlessJS.AttributeValue.toString as any;\n\nexport const AttributePath_fromString: (str:string) => AttributePath_t = BrushlessJS.AttributePath.fromString as any;\n\nexport const AttributePath_toString: (param:AttributePath_t) => string = BrushlessJS.AttributePath.toString as any;\n\nexport const Register_make: () => Register_t = BrushlessJS.Register.make as any;\n\nexport const Register_addValue: (register:Register_t, element:AttributeValue_t) => AttributeValue_t = BrushlessJS.Register.addValue as any;\n\nexport const Register_addName: (register:Register_t, element:AttributeName_t) => AttributeName_t = BrushlessJS.Register.addName as any;\n\nexport const Register_addPath: (register:Register_t, element:AttributePath_t) => AttributePath_t = BrushlessJS.Register.addPath as any;\n\nexport const Identifier_toString: (identifier:Identifier_t, register:Register_t) => string = BrushlessJS.Identifier.toString as any;\n\nexport const Condition_Maker_equals: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.equals as any;\n\nexport const Condition_Maker_notEquals: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.notEquals as any;\n\nexport const Condition_Maker_lessThan: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.lessThan as any;\n\nexport const Condition_Maker_lessThanOrEqualTo: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.lessThanOrEqualTo as any;\n\nexport const Condition_Maker_greaterThan: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.greaterThan as any;\n\nexport const Condition_Maker_greaterThanOrEqualTo: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.greaterThanOrEqualTo as any;\n\nexport const Condition_Maker_between: (operand:Condition_operand, limits:Condition_limits) => Condition_condition = BrushlessJS.Condition.Maker.between as any;\n\nexport const Condition_Maker_inList: (operand:Condition_operand, list:Condition_operand[]) => Condition_condition = BrushlessJS.Condition.Maker.inList as any;\n\nexport const Condition_Maker_attributeExists: (identifier:Identifier_t) => Condition_condition = BrushlessJS.Condition.Maker.attributeExists as any;\n\nexport const Condition_Maker_attributeNotExists: (identifier:Identifier_t) => Condition_condition = BrushlessJS.Condition.Maker.attributeNotExists as any;\n\nexport const Condition_Maker_attributeType: (identifier:Identifier_t, operand:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.attributeType as any;\n\nexport const Condition_Maker_beginsWith: (identifier:Identifier_t, operand:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.beginsWith as any;\n\nexport const Condition_Maker_contains: (identifier:Identifier_t, operand:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.contains as any;\n\nexport const Condition_Maker_toContains: (identifier:Identifier_t, operand:Condition_operand) => Condition_condition = BrushlessJS.Condition.Maker.toContains as any;\n\nexport const Condition_Maker_and: (lhs:Condition_condition, rhs:Condition_condition) => Condition_condition = BrushlessJS.Condition.Maker.and as any;\n\nexport const Condition_Maker_or: (lhs:Condition_condition, rhs:Condition_condition) => Condition_condition = BrushlessJS.Condition.Maker.or as any;\n\nexport const Condition_Maker_not: (condition:Condition_condition) => Condition_condition = BrushlessJS.Condition.Maker.not as any;\n\nexport const Condition_Maker_size: (operand:Condition_operand) => Condition_operand = BrushlessJS.Condition.Maker.size as any;\n\nexport const Condition_equals: (_1:Condition_operand, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.equals as any;\n\nexport const Condition_notEquals: (_1:Condition_operand, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.notEquals as any;\n\nexport const Condition_lessThan: (_1:Condition_operand, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.lessThan as any;\n\nexport const Condition_lessThanOrEqualTo: (_1:Condition_operand, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.lessThanOrEqualTo as any;\n\nexport const Condition_greaterThan: (_1:Condition_operand, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.greaterThan as any;\n\nexport const Condition_greaterThanOrEqualTo: (_1:Condition_operand, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.greaterThanOrEqualTo as any;\n\nexport const Condition_between: (_1:Condition_operand, _2:Condition_limits) => Condition_condition = BrushlessJS.Condition.between as any;\n\nexport const Condition_inList: (_1:Condition_operand, _2:Condition_operand[]) => Condition_condition = BrushlessJS.Condition.inList as any;\n\nexport const Condition_attributeExists: (_1:Identifier_t) => Condition_condition = BrushlessJS.Condition.attributeExists as any;\n\nexport const Condition_attributeNotExists: (_1:Identifier_t) => Condition_condition = BrushlessJS.Condition.attributeNotExists as any;\n\nexport const Condition_attributeType: (_1:Identifier_t, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.attributeType as any;\n\nexport const Condition_beginsWith: (_1:Identifier_t, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.beginsWith as any;\n\nexport const Condition_contains: (_1:Identifier_t, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.contains as any;\n\nexport const Condition_toContains: (_1:Identifier_t, _2:Condition_operand) => Condition_condition = BrushlessJS.Condition.toContains as any;\n\nexport const Condition_and: (_1:Condition_condition, _2:Condition_condition) => Condition_condition = BrushlessJS.Condition.and as any;\n\nexport const Condition_or: (_1:Condition_condition, _2:Condition_condition) => Condition_condition = BrushlessJS.Condition.or as any;\n\nexport const Condition_not: (_1:Condition_condition) => Condition_condition = BrushlessJS.Condition.not as any;\n\nexport const Condition_size: (_1:Condition_operand) => Condition_operand = BrushlessJS.Condition.size as any;\n\nexport const Condition_build: (condition:Condition_condition, register:Register_t) => string = BrushlessJS.Condition.build as any;\n\nexport const Projection_build: (projection:Projection_projection, register:Register_t) => string = BrushlessJS.Projection.build as any;\n\nexport const KeyCondition_Maker_equals: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.equals as any;\n\nexport const KeyCondition_Maker_notEquals: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.notEquals as any;\n\nexport const KeyCondition_Maker_lessThan: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.lessThan as any;\n\nexport const KeyCondition_Maker_lessThanOrEqualTo: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.lessThanOrEqualTo as any;\n\nexport const KeyCondition_Maker_greaterThan: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.greaterThan as any;\n\nexport const KeyCondition_Maker_greaterThanOrEqualTo: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.greaterThanOrEqualTo as any;\n\nexport const KeyCondition_Maker_between: (name:AttributeName_t, limits:KeyCondition_limits) => KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.between as any;\n\nexport const KeyCondition_Maker_beginsWith: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.beginsWith as any;\n\nexport const KeyCondition_Maker_any: KeyCondition_skCondition = BrushlessJS.KeyCondition.Maker.any as any;\n\nexport const KeyCondition_equals: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.equals as any;\n\nexport const KeyCondition_notEquals: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.notEquals as any;\n\nexport const KeyCondition_lessThan: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.lessThan as any;\n\nexport const KeyCondition_lessThanOrEqualTo: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.lessThanOrEqualTo as any;\n\nexport const KeyCondition_greaterThan: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.greaterThan as any;\n\nexport const KeyCondition_greaterThanOrEqualTo: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.greaterThanOrEqualTo as any;\n\nexport const KeyCondition_between: (_1:AttributeName_t, _2:KeyCondition_limits) => KeyCondition_skCondition = BrushlessJS.KeyCondition.between as any;\n\nexport const KeyCondition_beginsWith: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition = BrushlessJS.KeyCondition.beginsWith as any;\n\nexport const KeyCondition_any: KeyCondition_skCondition = BrushlessJS.KeyCondition.any as any;\n\nexport const KeyCondition_build: (keyCondition:KeyCondition_keyCondition, register:Register_t) => string = BrushlessJS.KeyCondition.build as any;\n\nexport const Update_Maker_listAppend: (identifier:Update_operand, operand:Update_operand) => Update_operand = BrushlessJS.Update.Maker.listAppend as any;\n\nexport const Update_Maker_ifNotExists: (identifier:Update_operand, operand:Update_operand) => Update_operand = BrushlessJS.Update.Maker.ifNotExists as any;\n\nexport const Update_Maker_sum: (lhs:Update_operand, rhs:Update_operand) => Update_operand = BrushlessJS.Update.Maker.sum as any;\n\nexport const Update_Maker_sub: (lhs:Update_operand, rhs:Update_operand) => Update_operand = BrushlessJS.Update.Maker.sub as any;\n\nexport const Update_listAppend: (_1:Update_operand, _2:Update_operand) => Update_operand = BrushlessJS.Update.listAppend as any;\n\nexport const Update_ifNotExists: (_1:Update_operand, _2:Update_operand) => Update_operand = BrushlessJS.Update.ifNotExists as any;\n\nexport const Update_sum: (_1:Update_operand, _2:Update_operand) => Update_operand = BrushlessJS.Update.sum as any;\n\nexport const Update_sub: (_1:Update_operand, _2:Update_operand) => Update_operand = BrushlessJS.Update.sub as any;\n\nexport const Update_build: (update:Update_update, register:Register_t) => string = BrushlessJS.Update.build as any;\n\nexport const U_listAppend: (_1:U_operand, _2:U_operand) => U_operand = BrushlessJS.U.listAppend as any;\n\nexport const U_ifNotExists: (_1:U_operand, _2:U_operand) => U_operand = BrushlessJS.U.ifNotExists as any;\n\nexport const U_sum: (_1:U_operand, _2:U_operand) => U_operand = BrushlessJS.U.sum as any;\n\nexport const U_sub: (_1:U_operand, _2:U_operand) => U_operand = BrushlessJS.U.sub as any;\n\nexport const U_build: (_1:U_update, _2:Register_t) => string = BrushlessJS.U.build as any;\n\nexport const C_equals: (_1:C_operand, _2:C_operand) => C_condition = BrushlessJS.C.equals as any;\n\nexport const C_notEquals: (_1:C_operand, _2:C_operand) => C_condition = BrushlessJS.C.notEquals as any;\n\nexport const C_lessThan: (_1:C_operand, _2:C_operand) => C_condition = BrushlessJS.C.lessThan as any;\n\nexport const C_lessThanOrEqualTo: (_1:C_operand, _2:C_operand) => C_condition = BrushlessJS.C.lessThanOrEqualTo as any;\n\nexport const C_greaterThan: (_1:C_operand, _2:C_operand) => C_condition = BrushlessJS.C.greaterThan as any;\n\nexport const C_greaterThanOrEqualTo: (_1:C_operand, _2:C_operand) => C_condition = BrushlessJS.C.greaterThanOrEqualTo as any;\n\nexport const C_between: (_1:C_operand, _2:C_limits) => C_condition = BrushlessJS.C.between as any;\n\nexport const C_inList: (_1:C_operand, _2:C_operand[]) => C_condition = BrushlessJS.C.inList as any;\n\nexport const C_attributeExists: (_1:Identifier_t) => C_condition = BrushlessJS.C.attributeExists as any;\n\nexport const C_attributeNotExists: (_1:Identifier_t) => C_condition = BrushlessJS.C.attributeNotExists as any;\n\nexport const C_attributeType: (_1:Identifier_t, _2:C_operand) => C_condition = BrushlessJS.C.attributeType as any;\n\nexport const C_beginsWith: (_1:Identifier_t, _2:C_operand) => C_condition = BrushlessJS.C.beginsWith as any;\n\nexport const C_contains: (_1:Identifier_t, _2:C_operand) => C_condition = BrushlessJS.C.contains as any;\n\nexport const C_toContains: (_1:Identifier_t, _2:C_operand) => C_condition = BrushlessJS.C.toContains as any;\n\nexport const C_and: (_1:C_condition, _2:C_condition) => C_condition = BrushlessJS.C.and as any;\n\nexport const C_or: (_1:C_condition, _2:C_condition) => C_condition = BrushlessJS.C.or as any;\n\nexport const C_not: (_1:C_condition) => C_condition = BrushlessJS.C.not as any;\n\nexport const C_size: (_1:C_operand) => C_operand = BrushlessJS.C.size as any;\n\nexport const C_build: (_1:C_condition, _2:Register_t) => string = BrushlessJS.C.build as any;\n\nexport const K_equals: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition = BrushlessJS.K.equals as any;\n\nexport const K_notEquals: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition = BrushlessJS.K.notEquals as any;\n\nexport const K_lessThan: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition = BrushlessJS.K.lessThan as any;\n\nexport const K_lessThanOrEqualTo: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition = BrushlessJS.K.lessThanOrEqualTo as any;\n\nexport const K_greaterThan: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition = BrushlessJS.K.greaterThan as any;\n\nexport const K_greaterThanOrEqualTo: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition = BrushlessJS.K.greaterThanOrEqualTo as any;\n\nexport const K_between: (_1:AttributeName_t, _2:K_limits) => K_skCondition = BrushlessJS.K.between as any;\n\nexport const K_beginsWith: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition = BrushlessJS.K.beginsWith as any;\n\nexport const K_any: K_skCondition = BrushlessJS.K.any as any;\n\nexport const K_build: (_1:K_keyCondition, _2:Register_t) => string = BrushlessJS.K.build as any;\n\nexport const P_build: (_1:P_projection, _2:Register_t) => string = BrushlessJS.P.build as any;\n\nexport const AttributeName: { toString: (name:AttributeName_t) => string; make: (name:string) => AttributeName_t } = BrushlessJS.AttributeName as any;\n\nexport const K: {\n  notEquals: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition; \n  greaterThan: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition; \n  greaterThanOrEqualTo: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition; \n  between: (_1:AttributeName_t, _2:K_limits) => K_skCondition; \n  lessThanOrEqualTo: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition; \n  build: (_1:K_keyCondition, _2:Register_t) => string; \n  any: K_skCondition; \n  lessThan: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition; \n  equals: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition; \n  beginsWith: (_1:AttributeName_t, _2:AttributeValue_t) => K_skCondition\n} = BrushlessJS.K as any;\n\nexport const Identifier: { toString: (identifier:Identifier_t, register:Register_t) => string } = BrushlessJS.Identifier as any;\n\nexport const Condition: {\n  attributeType: (_1:Identifier_t, _2:Condition_operand) => Condition_condition; \n  toContains: (_1:Identifier_t, _2:Condition_operand) => Condition_condition; \n  notEquals: (_1:Condition_operand, _2:Condition_operand) => Condition_condition; \n  attributeNotExists: (_1:Identifier_t) => Condition_condition; \n  greaterThan: (_1:Condition_operand, _2:Condition_operand) => Condition_condition; \n  greaterThanOrEqualTo: (_1:Condition_operand, _2:Condition_operand) => Condition_condition; \n  between: (_1:Condition_operand, _2:Condition_limits) => Condition_condition; \n  inList: (_1:Condition_operand, _2:Condition_operand[]) => Condition_condition; \n  and: (_1:Condition_condition, _2:Condition_condition) => Condition_condition; \n  size: (_1:Condition_operand) => Condition_operand; \n  lessThanOrEqualTo: (_1:Condition_operand, _2:Condition_operand) => Condition_condition; \n  build: (condition:Condition_condition, register:Register_t) => string; \n  not: (_1:Condition_condition) => Condition_condition; \n  lessThan: (_1:Condition_operand, _2:Condition_operand) => Condition_condition; \n  equals: (_1:Condition_operand, _2:Condition_operand) => Condition_condition; \n  Maker: {\n    attributeType: (identifier:Identifier_t, operand:Condition_operand) => Condition_condition; \n    toContains: (identifier:Identifier_t, operand:Condition_operand) => Condition_condition; \n    notEquals: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition; \n    attributeNotExists: (identifier:Identifier_t) => Condition_condition; \n    greaterThan: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition; \n    greaterThanOrEqualTo: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition; \n    between: (operand:Condition_operand, limits:Condition_limits) => Condition_condition; \n    inList: (operand:Condition_operand, list:Condition_operand[]) => Condition_condition; \n    and: (lhs:Condition_condition, rhs:Condition_condition) => Condition_condition; \n    size: (operand:Condition_operand) => Condition_operand; \n    lessThanOrEqualTo: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition; \n    not: (condition:Condition_condition) => Condition_condition; \n    lessThan: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition; \n    equals: (lhs:Condition_operand, rhs:Condition_operand) => Condition_condition; \n    beginsWith: (identifier:Identifier_t, operand:Condition_operand) => Condition_condition; \n    or: (lhs:Condition_condition, rhs:Condition_condition) => Condition_condition; \n    attributeExists: (identifier:Identifier_t) => Condition_condition; \n    contains: (identifier:Identifier_t, operand:Condition_operand) => Condition_condition\n  }; \n  beginsWith: (_1:Identifier_t, _2:Condition_operand) => Condition_condition; \n  or: (_1:Condition_condition, _2:Condition_condition) => Condition_condition; \n  attributeExists: (_1:Identifier_t) => Condition_condition; \n  contains: (_1:Identifier_t, _2:Condition_operand) => Condition_condition\n} = BrushlessJS.Condition as any;\n\nexport const KeyCondition: {\n  notEquals: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition; \n  greaterThan: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition; \n  greaterThanOrEqualTo: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition; \n  between: (_1:AttributeName_t, _2:KeyCondition_limits) => KeyCondition_skCondition; \n  lessThanOrEqualTo: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition; \n  build: (keyCondition:KeyCondition_keyCondition, register:Register_t) => string; \n  any: KeyCondition_skCondition; \n  lessThan: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition; \n  equals: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition; \n  Maker: {\n    notEquals: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition; \n    greaterThan: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition; \n    greaterThanOrEqualTo: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition; \n    between: (name:AttributeName_t, limits:KeyCondition_limits) => KeyCondition_skCondition; \n    lessThanOrEqualTo: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition; \n    any: KeyCondition_skCondition; \n    lessThan: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition; \n    equals: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition; \n    beginsWith: (name:AttributeName_t, value:AttributeValue_t) => KeyCondition_skCondition\n  }; \n  beginsWith: (_1:AttributeName_t, _2:AttributeValue_t) => KeyCondition_skCondition\n} = BrushlessJS.KeyCondition as any;\n\nexport const Update: {\n  sub: (_1:Update_operand, _2:Update_operand) => Update_operand; \n  listAppend: (_1:Update_operand, _2:Update_operand) => Update_operand; \n  ifNotExists: (_1:Update_operand, _2:Update_operand) => Update_operand; \n  sum: (_1:Update_operand, _2:Update_operand) => Update_operand; \n  build: (update:Update_update, register:Register_t) => string; \n  Maker: {\n    sub: (lhs:Update_operand, rhs:Update_operand) => Update_operand; \n    listAppend: (identifier:Update_operand, operand:Update_operand) => Update_operand; \n    ifNotExists: (identifier:Update_operand, operand:Update_operand) => Update_operand; \n    sum: (lhs:Update_operand, rhs:Update_operand) => Update_operand\n  }\n} = BrushlessJS.Update as any;\n\nexport const Register: {\n  addValue: (register:Register_t, element:AttributeValue_t) => AttributeValue_t; \n  addPath: (register:Register_t, element:AttributePath_t) => AttributePath_t; \n  addName: (register:Register_t, element:AttributeName_t) => AttributeName_t; \n  make: () => Register_t\n} = BrushlessJS.Register as any;\n\nexport const Projection: { build: (projection:Projection_projection, register:Register_t) => string } = BrushlessJS.Projection as any;\n\nexport const AttributePath: { fromString: (str:string) => AttributePath_t; toString: (param:AttributePath_t) => string } = BrushlessJS.AttributePath as any;\n\nexport const U: {\n  sub: (_1:U_operand, _2:U_operand) => U_operand; \n  listAppend: (_1:U_operand, _2:U_operand) => U_operand; \n  ifNotExists: (_1:U_operand, _2:U_operand) => U_operand; \n  sum: (_1:U_operand, _2:U_operand) => U_operand; \n  build: (_1:U_update, _2:Register_t) => string\n} = BrushlessJS.U as any;\n\nexport const C: {\n  attributeType: (_1:Identifier_t, _2:C_operand) => C_condition; \n  toContains: (_1:Identifier_t, _2:C_operand) => C_condition; \n  notEquals: (_1:C_operand, _2:C_operand) => C_condition; \n  attributeNotExists: (_1:Identifier_t) => C_condition; \n  greaterThan: (_1:C_operand, _2:C_operand) => C_condition; \n  greaterThanOrEqualTo: (_1:C_operand, _2:C_operand) => C_condition; \n  between: (_1:C_operand, _2:C_limits) => C_condition; \n  inList: (_1:C_operand, _2:C_operand[]) => C_condition; \n  and: (_1:C_condition, _2:C_condition) => C_condition; \n  size: (_1:C_operand) => C_operand; \n  lessThanOrEqualTo: (_1:C_operand, _2:C_operand) => C_condition; \n  build: (_1:C_condition, _2:Register_t) => string; \n  not: (_1:C_condition) => C_condition; \n  lessThan: (_1:C_operand, _2:C_operand) => C_condition; \n  equals: (_1:C_operand, _2:C_operand) => C_condition; \n  beginsWith: (_1:Identifier_t, _2:C_operand) => C_condition; \n  or: (_1:C_condition, _2:C_condition) => C_condition; \n  attributeExists: (_1:Identifier_t) => C_condition; \n  contains: (_1:Identifier_t, _2:C_operand) => C_condition\n} = BrushlessJS.C as any;\n\nexport const AttributeValue: { toString: (value:AttributeValue_t) => string; make: (x:AttributeValue_from<attributeValue>) => AttributeValue_t } = BrushlessJS.AttributeValue as any;\n\nexport const P: { build: (_1:P_projection, _2:Register_t) => string } = BrushlessJS.P as any;\n","import * as Brushless from './Brushless.bs'\n\n\nexport const AttributeName = Brushless.AttributeName\nexport const AttributePath = Brushless.AttributePath\nexport const AttributeValue = Brushless.AttributeValue\nexport const Condition = Brushless.Condition\nexport const KeyCondition = Brushless.KeyCondition\nexport const Update = Brushless.Update\nexport const Projection = Brushless.Projection\nexport const Register = Brushless.Register\nexport const C = Condition;\nexport const K = KeyCondition;\nexport const U = Update;\nexport const P = Projection;\nexport const R = Register;"],"mappings":"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","names":["AttributeName","AttributeValue","str","acc","match","AttributePath","sub","name","Register","Identifier","condition","Condition","Projection","KeyCondition","Update","U","C","K","P","AttributeName","AttributePath","AttributeValue","Condition","KeyCondition","Update","Projection","Register","C","K","U","P"]}