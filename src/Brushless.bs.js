// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';


function throwError(message) { throw new Error(message); }
;

function attributeName(param_0) {
  return {
          TAG: "AttributeName",
          _0: param_0
        };
}

function attributeValue(param_0) {
  return {
          TAG: "AttributeValue",
          _0: param_0
        };
}

function make(x) {
  return {
          TAG: "AttributeValue",
          _0: x
        };
}

function attributePath(param_0, param_1) {
  return {
          TAG: "AttributePath",
          _0: param_0,
          _1: param_1
        };
}

function splitWhen(str, predicate) {
  var _index = 0;
  while(true) {
    var index = _index;
    var $$char = str[index];
    if ($$char === undefined) {
      return [
              str,
              "",
              ""
            ];
    }
    if (predicate($$char)) {
      return [
              str.substring(0, index),
              str.substring(index, index + 1 | 0),
              str.substring(index + 1 | 0)
            ];
    }
    _index = index + 1 | 0;
    continue ;
  };
}

function pathFromString(str) {
  var parse = function (_str, _prevState, acc) {
    while(true) {
      var prevState = _prevState;
      var str = _str;
      var match = splitWhen(str, (function ($$char) {
              if ($$char === "[") {
                return true;
              } else {
                return $$char === ".";
              }
            }));
      if (match[0] === "" && match[1] === "" && match[2] === "") {
        return {
                TAG: "Ok",
                _0: acc
              };
      }
      if (prevState === "Name") {
        var name = match[0];
        switch (match[1]) {
          case "" :
              if (match[2] === "" && name !== "") {
                acc.push({
                      TAG: "AttributeName",
                      _0: name
                    });
                return {
                        TAG: "Ok",
                        _0: acc
                      };
              } else {
                return {
                        TAG: "Error",
                        _0: "InvalidPath"
                      };
              }
          case "." :
              if (name === "") {
                return {
                        TAG: "Error",
                        _0: "InvalidPath"
                      };
              }
              acc.push({
                    TAG: "AttributeName",
                    _0: name
                  });
              _prevState = "Name";
              _str = match[2];
              continue ;
          case "[" :
              if (name !== "") {
                acc.push({
                      TAG: "AttributeName",
                      _0: name
                    });
                return parseIndex(match[2], acc);
              } else {
                return {
                        TAG: "Error",
                        _0: "InvalidPath"
                      };
              }
          default:
            return {
                    TAG: "Error",
                    _0: "InvalidPath"
                  };
        }
      } else {
        if (match[0] !== "") {
          return {
                  TAG: "Error",
                  _0: "InvalidPath"
                };
        }
        switch (match[1]) {
          case "." :
              _prevState = "Name";
              _str = match[2];
              continue ;
          case "[" :
              return parseIndex(match[2], acc);
          default:
            return {
                    TAG: "Error",
                    _0: "InvalidPath"
                  };
        }
      }
    };
  };
  var parseIndex = function (rest, acc) {
    var match = splitWhen(rest, (function ($$char) {
            return $$char === "]";
          }));
    var index = match[0];
    if (match[1] === "]" && index.search(/^[0-9]+$/) !== -1) {
      acc.push({
            TAG: "ListIndex",
            _0: parseInt(index) | 0
          });
      return parse(match[2], "Index", acc);
    } else {
      return {
              TAG: "Error",
              _0: {
                TAG: "InvalidIndex",
                _0: index
              }
            };
    }
  };
  var acc = [];
  var path = parse(str, "Name", acc);
  if (path.TAG !== "Ok") {
    return path;
  }
  var match = path._0.shift();
  if (match !== undefined) {
    if (match.TAG === "AttributeName") {
      return {
              TAG: "Ok",
              _0: {
                TAG: "AttributePath",
                _0: {
                  TAG: "AttributeName",
                  _0: match._0
                },
                _1: acc
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: "MissingBaseNameBeforeIndex"
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: "EmptyPath"
          };
  }
}

function pathFromStringUnsafe(path) {
  var path$1 = pathFromString(path);
  if (path$1.TAG === "Ok") {
    return path$1._0;
  } else {
    return throwError(JSON.stringify(path$1._0));
  }
}

function toString(x) {
  var nameToString = function (name) {
    if (name.includes(" ")) {
      throwError("InvalidName");
    }
    return "#" + name;
  };
  switch (x.TAG) {
    case "AttributePath" :
        return x._1.reduce((function (acc, sub) {
                      if (sub.TAG === "AttributeName") {
                        return acc + "." + nameToString(sub._0);
                      } else {
                        return acc + "[" + String(sub._0) + "]";
                      }
                    }), nameToString(x._0._0));
    case "AttributeName" :
        return nameToString(x._0);
    case "AttributeValue" :
        return ":" + x._0.alias;
    
  }
}

var Attribute = {
  attributeName: attributeName,
  attributeValue: attributeValue,
  make: make,
  attributePath: attributePath,
  pathFromString: pathFromString,
  pathFromStringUnsafe: pathFromStringUnsafe,
  toString: toString
};

function make$1() {
  return {
          names: {},
          values: {}
        };
}

function add(register, element) {
  switch (element.TAG) {
    case "AttributePath" :
        [element._0].concat(element._1).forEach(function (sub) {
              if (sub.TAG !== "AttributeName") {
                return ;
              }
              var name = sub._0;
              register.names[toString({
                        TAG: "AttributeName",
                        _0: name
                      })] = name;
            });
        break;
    case "AttributeName" :
        register.names[toString(element)] = element._0;
        break;
    case "AttributeValue" :
        register.values[toString(element)] = element._0.value;
        break;
    
  }
  return element;
}

function addToString(register, element) {
  return toString(add(register, element));
}

var Register = {
  make: make$1,
  add: add,
  addToString: addToString
};

function size(param_0) {
  return {
          TAG: "Size",
          _0: param_0
        };
}

function equals(param_0, param_1) {
  return {
          TAG: "Equals",
          _0: param_0,
          _1: param_1
        };
}

function notEquals(param_0, param_1) {
  return {
          TAG: "NotEquals",
          _0: param_0,
          _1: param_1
        };
}

function lessThan(param_0, param_1) {
  return {
          TAG: "LessThan",
          _0: param_0,
          _1: param_1
        };
}

function lessThanOrEqual(param_0, param_1) {
  return {
          TAG: "LessThanOrEqual",
          _0: param_0,
          _1: param_1
        };
}

function greaterThan(param_0, param_1) {
  return {
          TAG: "GreaterThan",
          _0: param_0,
          _1: param_1
        };
}

function greaterThanOrEqual(param_0, param_1) {
  return {
          TAG: "GreaterThanOrEqual",
          _0: param_0,
          _1: param_1
        };
}

function between(param_0, param_1) {
  return {
          TAG: "Between",
          _0: param_0,
          _1: param_1
        };
}

function inList(param_0, param_1) {
  return {
          TAG: "InList",
          _0: param_0,
          _1: param_1
        };
}

function and(param_0, param_1) {
  return {
          TAG: "And",
          _0: param_0,
          _1: param_1
        };
}

function or(param_0, param_1) {
  return {
          TAG: "Or",
          _0: param_0,
          _1: param_1
        };
}

function not(param_0) {
  return {
          TAG: "Not",
          _0: param_0
        };
}

function attributeExists(param_0) {
  return {
          TAG: "AttributeExists",
          _0: param_0
        };
}

function attributeNotExists(param_0) {
  return {
          TAG: "AttributeNotExists",
          _0: param_0
        };
}

function attributeType(param_0, param_1) {
  return {
          TAG: "AttributeType",
          _0: param_0,
          _1: param_1
        };
}

function beginsWith(param_0, param_1) {
  return {
          TAG: "BeginsWith",
          _0: param_0,
          _1: param_1
        };
}

function contains(param_0, param_1) {
  return {
          TAG: "Contains",
          _0: param_0,
          _1: param_1
        };
}

var Overload = {
  $amp$amp: and,
  $pipe$pipe: or,
  $bang: not,
  $eq$eq: equals,
  $bang$eq: notEquals,
  $less: lessThan,
  $less$eq: lessThanOrEqual,
  $great: greaterThan,
  $great$eq: greaterThanOrEqual
};

function build(condition, register) {
  var toString = function (condition) {
    switch (condition.TAG) {
      case "Equals" :
          return opString(condition._0) + " = " + opString(condition._1);
      case "NotEquals" :
          return opString(condition._0) + " <> " + opString(condition._1);
      case "LessThan" :
          return opString(condition._0) + " < " + opString(condition._1);
      case "LessThanOrEqual" :
          return opString(condition._0) + " <= " + opString(condition._1);
      case "GreaterThan" :
          return opString(condition._0) + " > " + opString(condition._1);
      case "GreaterThanOrEqual" :
          return opString(condition._0) + " >= " + opString(condition._1);
      case "Between" :
          var limits = condition._1;
          return opString(condition._0) + " BETWEEN " + opString(limits.lower) + " AND " + opString(limits.upper);
      case "InList" :
          return opString(condition._0) + " IN (" + condition._1.map(opString).join(", ") + ")";
      case "And" :
          return "(" + toString(condition._0) + ") AND (" + toString(condition._1) + ")";
      case "Or" :
          return "(" + toString(condition._0) + ") OR (" + toString(condition._1) + ")";
      case "Not" :
          return "NOT (" + toString(condition._0) + ")";
      case "AttributeExists" :
          return "attribute_exists(" + opString(condition._0) + "})";
      case "AttributeNotExists" :
          return "attribute_not_exists(" + opString(condition._0) + "})";
      case "AttributeType" :
          return "attribute_type(" + opString(condition._0) + "}, " + opString(condition._1) + ")";
      case "BeginsWith" :
          return "begins_with(" + opString(condition._0) + "}, " + opString(condition._1) + ")";
      case "Contains" :
          return "contains(" + opString(condition._0) + "}, " + opString(condition._1) + ")";
      
    }
  };
  var opString = function (operand) {
    switch (operand.TAG) {
      case "AttributePath" :
          return addToString(register, {
                      TAG: "AttributePath",
                      _0: operand._0,
                      _1: operand._1
                    });
      case "AttributeName" :
          return addToString(register, {
                      TAG: "AttributeName",
                      _0: operand._0
                    });
      case "AttributeValue" :
          return addToString(register, {
                      TAG: "AttributeValue",
                      _0: operand._0
                    });
      case "Size" :
          return "size(" + opString(operand._0) + "})";
      
    }
  };
  return toString(condition);
}

var Condition = {
  size: size,
  equals: equals,
  notEquals: notEquals,
  lessThan: lessThan,
  lessThanOrEqual: lessThanOrEqual,
  greaterThan: greaterThan,
  greaterThanOrEqual: greaterThanOrEqual,
  between: between,
  inList: inList,
  and: and,
  or: or,
  not: not,
  attributeExists: attributeExists,
  attributeNotExists: attributeNotExists,
  attributeType: attributeType,
  beginsWith: beginsWith,
  contains: contains,
  Overload: Overload,
  build: build
};

function build$1(projection, register) {
  return projection.map(function (x) {
                return addToString(register, x);
              }).join(", ");
}

var Projection = {
  build: build$1
};

function partitionKey(param_0, param_1) {
  return {
          TAG: "PartitionKey",
          _0: param_0,
          _1: param_1
        };
}

function equals$1(param_0, param_1) {
  return {
          TAG: "Equals",
          _0: param_0,
          _1: param_1
        };
}

function notEquals$1(param_0, param_1) {
  return {
          TAG: "NotEquals",
          _0: param_0,
          _1: param_1
        };
}

function lessThan$1(param_0, param_1) {
  return {
          TAG: "LessThan",
          _0: param_0,
          _1: param_1
        };
}

function lessThanOrEqual$1(param_0, param_1) {
  return {
          TAG: "LessThanOrEqual",
          _0: param_0,
          _1: param_1
        };
}

function greaterThan$1(param_0, param_1) {
  return {
          TAG: "GreaterThan",
          _0: param_0,
          _1: param_1
        };
}

function greaterThanOrEqual$1(param_0, param_1) {
  return {
          TAG: "GreaterThanOrEqual",
          _0: param_0,
          _1: param_1
        };
}

function between$1(param_0, param_1) {
  return {
          TAG: "Between",
          _0: param_0,
          _1: param_1
        };
}

function beginsWith$1(param_0, param_1) {
  return {
          TAG: "BeginsWith",
          _0: param_0,
          _1: param_1
        };
}

function skConditionToString(skCondition, register) {
  switch (skCondition.TAG) {
    case "Equals" :
        return " AND " + addToString(register, skCondition._0) + " = " + addToString(register, skCondition._1);
    case "NotEquals" :
        return " AND " + addToString(register, skCondition._0) + " <> " + addToString(register, skCondition._1);
    case "LessThan" :
        return " AND " + addToString(register, skCondition._0) + " < " + addToString(register, skCondition._1);
    case "LessThanOrEqual" :
        return " AND " + addToString(register, skCondition._0) + " <= " + addToString(register, skCondition._1);
    case "GreaterThan" :
        return " AND " + addToString(register, skCondition._0) + " > " + addToString(register, skCondition._1);
    case "GreaterThanOrEqual" :
        return " AND " + addToString(register, skCondition._0) + " >= " + addToString(register, skCondition._1);
    case "Between" :
        var limits = skCondition._1;
        return " AND " + addToString(register, skCondition._0) + " BETWEEN " + addToString(register, limits.lower) + " AND " + addToString(register, limits.upper);
    case "BeginsWith" :
        return " AND begins_with(" + addToString(register, skCondition._0) + ", " + addToString(register, skCondition._1) + ")";
    
  }
}

function pkConditionToString(param, register) {
  return addToString(register, param._0) + " = " + addToString(register, param._1);
}

function build$2(condition, register) {
  var skCondition = condition.sk;
  return pkConditionToString(condition.pk, register) + (
          skCondition !== undefined ? skConditionToString(skCondition, register) : ""
        );
}

var KeyCondition = {
  partitionKey: partitionKey,
  equals: equals$1,
  notEquals: notEquals$1,
  lessThan: lessThan$1,
  lessThanOrEqual: lessThanOrEqual$1,
  greaterThan: greaterThan$1,
  greaterThanOrEqual: greaterThanOrEqual$1,
  between: between$1,
  beginsWith: beginsWith$1,
  build: build$2
};

function attribute(param_0) {
  return {
          TAG: "Attribute",
          _0: param_0
        };
}

function listAppend(param_0) {
  return {
          TAG: "ListAppend",
          _0: param_0
        };
}

function ifNotExists(param_0) {
  return {
          TAG: "IfNotExists",
          _0: param_0
        };
}

function sum(param_0, param_1) {
  return {
          TAG: "Sum",
          _0: param_0,
          _1: param_1
        };
}

function sub(param_0, param_1) {
  return {
          TAG: "Sub",
          _0: param_0,
          _1: param_1
        };
}

function operandToString(operand, register) {
  switch (operand.TAG) {
    case "Attribute" :
        return addToString(register, operand._0);
    case "ListAppend" :
        var match = operand._0;
        return "list_append(" + operandToString(match.identifier, register) + ", " + operandToString(match.operand, register) + ")";
    case "IfNotExists" :
        var match$1 = operand._0;
        return "if_not_exists(" + operandToString(match$1.identifier, register) + ", " + operandToString(match$1.operand, register) + ")";
    case "Sum" :
        return operandToString(operand._0, register) + " + " + operandToString(operand._1, register);
    case "Sub" :
        return operandToString(operand._0, register) + " - " + operandToString(operand._1, register);
    
  }
}

function appendIfNotEmpty(acc, arr, tag, fn) {
  if (arr !== undefined && arr.length > 0) {
    return acc + tag + " " + arr.map(fn).join(", ") + " ";
  } else {
    return acc;
  }
}

function build$3(update, register) {
  return appendIfNotEmpty(appendIfNotEmpty(appendIfNotEmpty(appendIfNotEmpty("", update.add, "ADD", (function (param) {
                              return addToString(register, param[0]) + " " + addToString(register, param[1]);
                            })), update.delete, "DELETE", (function (param) {
                          return addToString(register, param[0]) + " " + addToString(register, param[1]);
                        })), update.set, "SET", (function (param) {
                      return addToString(register, param[0]) + " = " + operandToString(param[1], register);
                    })), update.remove, "REMOVE", (function (x) {
                  return addToString(register, x);
                })).trim();
}

var Update = {
  attribute: attribute,
  listAppend: listAppend,
  ifNotExists: ifNotExists,
  sum: sum,
  sub: sub,
  build: build$3
};

exports.Attribute = Attribute;
exports.Register = Register;
exports.Condition = Condition;
exports.Projection = Projection;
exports.KeyCondition = KeyCondition;
exports.Update = Update;
/*  Not a pure module */
