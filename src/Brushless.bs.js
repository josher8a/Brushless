// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';


function make(name) {
  return {
    TAG: "AttributeName",
    name: name
  };
}

function toString(param) {
  let name = param.name;
  if (name.includes(" ") || name.includes(".")) {
    throw new Error("InvalidName");
  }
  return "#" + name.replaceAll("-", "_");
}

let AttributeName = {
  make: make,
  toString: toString
};

function make$1(x) {
  return {
    TAG: "AttributeValue",
    value: x.value,
    alias: x.alias
  };
}

function toString$1(param) {
  return ":" + param.alias;
}

let AttributeValue = {
  make: make$1,
  toString: toString$1
};

function splitWhen(str, predicate) {
  let _index = 0;
  while (true) {
    let index = _index;
    let char = str[index];
    if (char === undefined) {
      return [
        str,
        "",
        ""
      ];
    }
    if (predicate(char)) {
      return [
        str.substring(0, index),
        str.substring(index, index + 1 | 0),
        str.substring(index + 1 | 0)
      ];
    }
    _index = index + 1 | 0;
    continue;
  };
}

function fromString(str) {
  let parse = (_str, _state, _accOpt) => {
    while (true) {
      let accOpt = _accOpt;
      let state = _state;
      let str = _str;
      let acc = accOpt !== undefined ? accOpt : [];
      let match = splitWhen(str, char => {
        if (char === "[") {
          return true;
        } else {
          return char === ".";
        }
      });
      let rest = match[2];
      let name = match[0];
      if (state === "Name") {
        if (name === "") {
          throw new Error("InvalidPath");
        }
        acc.push({
          TAG: "AttributeName",
          name: name
        });
      } else if (name !== "") {
        throw new Error("InvalidPath");
      }
      switch (match[1]) {
        case "" :
          if (rest === "") {
            return acc;
          }
          throw new Error("InvalidPath");
        case "." :
          _accOpt = acc;
          _state = "Name";
          _str = rest;
          continue;
        case "[" :
          let match$1 = splitWhen(rest, char => char === "]");
          let index = match$1[0];
          if (match$1[1] === "]") {
            let x = parseInt(index);
            if (!isFinite(x) || x < 0 || index.length !== x.toString().length) {
              throw new Error("InvalidIndex: " + index);
            }
            acc.push({
              TAG: "ListIndex",
              index: x | 0
            });
            _accOpt = acc;
            _state = "Index";
            _str = match$1[2];
            continue;
          }
          throw new Error("InvalidPath");
        default:
          throw new Error("InvalidPath");
      }
    };
  };
  let acc = [];
  let match = parse(str, "Name", acc).shift();
  if (match !== undefined) {
    if (match.TAG === "AttributeName") {
      return {
        TAG: "AttributePath",
        name: match.name,
        subpath: acc
      };
    }
    throw new Error("InvalidPath");
  }
  throw new Error("InvalidPath");
}

function toString$2(param) {
  return param.subpath.reduce((acc, subs) => {
    if (subs.TAG === "AttributeName") {
      return acc + `.` + toString({
        TAG: "AttributeName",
        name: subs.name
      });
    } else {
      return acc + `[` + subs.index.toString() + `]`;
    }
  }, toString({
    TAG: "AttributeName",
    name: param.name
  }));
}

let AttributePath = {
  fromString: fromString,
  toString: toString$2
};

function make$2() {
  return {};
}

function isValueEqual(a, b) {
  let x = a.S;
  let exit = 0;
  if (x !== undefined) {
    let y = b.S;
    if (y !== undefined) {
      return x === y;
    }
    exit = 1;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    let x$1 = a.N;
    let exit$1 = 0;
    if (x$1 !== undefined) {
      let y$1 = b.N;
      if (y$1 !== undefined) {
        return x$1 === y$1;
      }
      exit$1 = 2;
    } else {
      exit$1 = 2;
    }
    if (exit$1 === 2) {
      let x$2 = a.B;
      let exit$2 = 0;
      let exit$3 = 0;
      let x$3 = a.SS;
      let exit$4 = 0;
      let exit$5 = 0;
      let x$4 = a.NULL;
      let exit$6 = 0;
      if (x$4 !== undefined) {
        let y$2 = b.NULL;
        if (y$2 !== undefined) {
          return x$4 === y$2;
        }
        exit$6 = 7;
      } else {
        exit$6 = 7;
      }
      if (exit$6 === 7) {
        let x$5 = a.BOOL;
        if (x$5 !== undefined) {
          let y$3 = b.BOOL;
          if (y$3 !== undefined) {
            return x$5 === y$3;
          }
          exit$5 = 6;
        } else {
          exit$5 = 6;
        }
      }
      if (exit$5 === 6) {
        if (x$3 !== undefined) {
          let y$4 = b.SS;
          if (y$4 !== undefined) {
            return x$3.every(v => y$4.includes(v));
          }
          exit$4 = 5;
        } else {
          exit$4 = 5;
        }
      }
      if (exit$4 === 5) {
        let x$6 = a.NS;
        let exit$7 = 0;
        if (x$6 !== undefined) {
          let y$5 = b.NS;
          if (y$5 !== undefined) {
            return x$6.every(v => y$5.includes(v));
          }
          exit$7 = 6;
        } else {
          exit$7 = 6;
        }
        if (exit$7 === 6) {
          let x$7 = a.M;
          let exit$8 = 0;
          let x$8 = a.L;
          if (x$8 !== undefined) {
            let y$6 = b.L;
            if (y$6 !== undefined) {
              if (x$8.length === y$6.length) {
                return x$8.every((v, i) => {
                  let y$7 = y$6[i];
                  if (y$7 !== undefined) {
                    return isValueEqual(v, y$7);
                  } else {
                    return false;
                  }
                });
              } else {
                return false;
              }
            }
            exit$8 = 7;
          } else {
            exit$8 = 7;
          }
          if (exit$8 === 7) {
            if (x$7 !== undefined) {
              let y$7 = b.M;
              if (y$7 !== undefined) {
                let keys = Object.entries(x$7);
                if (keys.length === Object.keys(y$7).length) {
                  return keys.every(param => {
                    let y$8 = y$7[param[0]];
                    if (y$8 !== undefined) {
                      return isValueEqual(param[1], y$8);
                    } else {
                      return false;
                    }
                  });
                } else {
                  return false;
                }
              }
              exit$3 = 4;
            } else {
              exit$3 = 4;
            }
          }
        }
      }
      if (exit$3 === 4) {
        if (x$2 !== undefined) {
          let y$8 = b.B;
          if (y$8 !== undefined) {
            return x$2.toString() === y$8.toString();
          }
          exit$2 = 3;
        } else {
          exit$2 = 3;
        }
      }
      if (exit$2 === 3) {
        let x$9 = a.BS;
        if (x$9 === undefined) {
          return false;
        }
        let y$9 = b.BS;
        if (y$9 !== undefined && x$9.length === y$9.length) {
          return x$9.every((v, i) => {
            let y$10 = y$9[i];
            if (y$10 !== undefined) {
              return v.toString() === y$10.toString();
            } else {
              return false;
            }
          });
        } else {
          return false;
        }
      }
    }
  }
}

function addValue(register, _element) {
  while (true) {
    let element = _element;
    let alias = element.alias;
    let value = element.value;
    let key = toString$1({
      TAG: "AttributeValue",
      value: value,
      alias: alias
    });
    let x = register.values;
    let dict = x !== undefined ? x : ({});
    let exist = dict[key];
    if (exist !== undefined && exist !== value && !isValueEqual(exist, value)) {
      _element = {
        TAG: "AttributeValue",
        value: value,
        alias: alias + "_"
      };
      continue;
    }
    dict[key] = value;
    register.values = dict;
    return element;
  };
}

function addName(register, element) {
  let name = element.name;
  let x = register.names;
  let dict = x !== undefined ? x : ({});
  dict[toString({
        TAG: "AttributeName",
        name: name
      })] = name;
  register.names = dict;
  return element;
}

function addPath(register, element) {
  let name = element.name;
  let x = register.names;
  let dict = x !== undefined ? x : ({});
  dict[toString({
        TAG: "AttributeName",
        name: name
      })] = name;
  element.subpath.forEach(sub => {
    if (sub.TAG !== "AttributeName") {
      return;
    }
    let name = sub.name;
    dict[toString({
          TAG: "AttributeName",
          name: name
        })] = name;
  });
  register.names = dict;
  return element;
}

let Register = {
  make: make$2,
  isValueEqual: isValueEqual,
  addValue: addValue,
  addName: addName,
  addPath: addPath
};

function toString$3(identifier, register) {
  if (identifier.TAG === "AttributePath") {
    return toString$2(addPath(register, {
      TAG: "AttributePath",
      name: identifier.name,
      subpath: identifier.subpath
    }));
  } else {
    return toString(addName(register, {
      TAG: "AttributeName",
      name: identifier.name
    }));
  }
}

let Identifier = {
  toString: toString$3
};

function equals(lhs, rhs) {
  return {
    TAG: "Comparison",
    lhs: lhs,
    comparator: "=",
    rhs: rhs
  };
}

function notEquals(lhs, rhs) {
  return {
    TAG: "Comparison",
    lhs: lhs,
    comparator: "<>",
    rhs: rhs
  };
}

function lessThan(lhs, rhs) {
  return {
    TAG: "Comparison",
    lhs: lhs,
    comparator: "<",
    rhs: rhs
  };
}

function lessThanOrEqualTo(lhs, rhs) {
  return {
    TAG: "Comparison",
    lhs: lhs,
    comparator: "<=",
    rhs: rhs
  };
}

function greaterThan(lhs, rhs) {
  return {
    TAG: "Comparison",
    lhs: lhs,
    comparator: ">",
    rhs: rhs
  };
}

function greaterThanOrEqualTo(lhs, rhs) {
  return {
    TAG: "Comparison",
    lhs: lhs,
    comparator: ">=",
    rhs: rhs
  };
}

function between(operand, limits) {
  return {
    TAG: "Between",
    operand: operand,
    limits: limits
  };
}

function inList(operand, list) {
  return {
    TAG: "In",
    operand: operand,
    list: list
  };
}

function attributeExists(identifier) {
  return {
    TAG: "AttributeExists",
    identifier: identifier
  };
}

function attributeNotExists(identifier) {
  return {
    TAG: "AttributeNotExists",
    identifier: identifier
  };
}

function attributeType(identifier, operand) {
  return {
    TAG: "AttributeType",
    identifier: identifier,
    operand: operand
  };
}

function beginsWith(identifier, operand) {
  return {
    TAG: "BeginsWith",
    identifier: identifier,
    operand: operand
  };
}

function contains(identifier, operand) {
  return {
    TAG: "Contains",
    identifier: identifier,
    operand: operand
  };
}

function toContains(identifier, operand) {
  return {
    TAG: "ToContains",
    identifier: identifier,
    operand: operand
  };
}

function and(lhs, rhs) {
  return {
    TAG: "And",
    lhs: lhs,
    rhs: rhs
  };
}

function or(lhs, rhs) {
  return {
    TAG: "Or",
    lhs: lhs,
    rhs: rhs
  };
}

function not(condition) {
  return {
    TAG: "Not",
    condition: condition
  };
}

function size(operand) {
  return {
    TAG: "Size",
    operand: operand
  };
}

let Overload = {
  $amp$amp: and,
  $pipe$pipe: or,
  $bang: not,
  $eq$eq: equals,
  $bang$eq: notEquals,
  $less: lessThan,
  $less$eq: lessThanOrEqualTo,
  $great: greaterThan,
  $great$eq: greaterThanOrEqualTo
};

function build(condition, register) {
  let toString$4 = condition => {
    switch (condition.TAG) {
      case "Comparison" :
        return opString(condition.lhs) + ` ` + condition.comparator + ` ` + opString(condition.rhs);
      case "Between" :
        let limits = condition.limits;
        return opString(condition.operand) + ` BETWEEN ` + opString(limits.lower) + ` AND ` + opString(limits.upper);
      case "In" :
        return opString(condition.operand) + ` IN (` + condition.list.map(opString).join(", ") + `)`;
      case "And" :
        return `(` + toString$4(condition.lhs) + `) AND (` + toString$4(condition.rhs) + `)`;
      case "Or" :
        return `(` + toString$4(condition.lhs) + `) OR (` + toString$4(condition.rhs) + `)`;
      case "Not" :
        return `NOT (` + toString$4(condition.condition) + `)`;
      case "AttributeExists" :
        return `attribute_exists(` + toString$3(condition.identifier, register) + `)`;
      case "AttributeNotExists" :
        return `attribute_not_exists(` + toString$3(condition.identifier, register) + `)`;
      case "AttributeType" :
        return `attribute_type(` + toString$3(condition.identifier, register) + `, ` + opString(condition.operand) + `)`;
      case "BeginsWith" :
        return `begins_with(` + toString$3(condition.identifier, register) + `, ` + opString(condition.operand) + `)`;
      case "Contains" :
        return `contains(` + toString$3(condition.identifier, register) + `, ` + opString(condition.operand) + `)`;
      case "ToContains" :
        return `contains(` + opString(condition.operand) + `, ` + toString$3(condition.identifier, register) + `)`;
    }
  };
  let opString = operand => {
    switch (operand.TAG) {
      case "AttributePath" :
        return toString$2(addPath(register, {
          TAG: "AttributePath",
          name: operand.name,
          subpath: operand.subpath
        }));
      case "AttributeName" :
        return toString(addName(register, {
          TAG: "AttributeName",
          name: operand.name
        }));
      case "AttributeValue" :
        return toString$1(addValue(register, {
          TAG: "AttributeValue",
          value: operand.value,
          alias: operand.alias
        }));
      case "Size" :
        return `size(` + opString(operand.operand) + `)`;
    }
  };
  return toString$4(condition);
}

let Condition = {
  equals: equals,
  notEquals: notEquals,
  lessThan: lessThan,
  lessThanOrEqualTo: lessThanOrEqualTo,
  greaterThan: greaterThan,
  greaterThanOrEqualTo: greaterThanOrEqualTo,
  between: between,
  inList: inList,
  attributeExists: attributeExists,
  attributeNotExists: attributeNotExists,
  attributeType: attributeType,
  beginsWith: beginsWith,
  contains: contains,
  toContains: toContains,
  and: and,
  or: or,
  not: not,
  size: size,
  Overload: Overload,
  build: build
};

function build$1(projection, register) {
  return projection.map(__x => toString$3(__x, register)).join(", ");
}

let Projection = {
  build: build$1
};

function equals$1(name, value) {
  return {
    TAG: "Comparison",
    name: name,
    comparator: "=",
    value: value
  };
}

function notEquals$1(name, value) {
  return {
    TAG: "Comparison",
    name: name,
    comparator: "<>",
    value: value
  };
}

function lessThan$1(name, value) {
  return {
    TAG: "Comparison",
    name: name,
    comparator: "<",
    value: value
  };
}

function lessThanOrEqualTo$1(name, value) {
  return {
    TAG: "Comparison",
    name: name,
    comparator: "<=",
    value: value
  };
}

function greaterThan$1(name, value) {
  return {
    TAG: "Comparison",
    name: name,
    comparator: ">",
    value: value
  };
}

function greaterThanOrEqualTo$1(name, value) {
  return {
    TAG: "Comparison",
    name: name,
    comparator: ">=",
    value: value
  };
}

function between$1(name, limits) {
  return {
    TAG: "Between",
    name: name,
    limits: limits
  };
}

function beginsWith$1(name, value) {
  return {
    TAG: "BeginsWith",
    name: name,
    value: value
  };
}

function skConditionToString(skCondition, register) {
  if (typeof skCondition !== "object") {
    return "";
  }
  switch (skCondition.TAG) {
    case "Comparison" :
      return ` AND ` + toString(addName(register, skCondition.name)) + ` ` + skCondition.comparator + ` ` + toString$1(addValue(register, skCondition.value));
    case "Between" :
      let limits = skCondition.limits;
      return ` AND ` + toString(addName(register, skCondition.name)) + ` BETWEEN ` + toString$1(addValue(register, limits.lower)) + ` AND ` + toString$1(addValue(register, limits.upper));
    case "BeginsWith" :
      return ` AND begins_with(` + toString(addName(register, skCondition.name)) + `, ` + toString$1(addValue(register, skCondition.value)) + `)`;
  }
}

function build$2(keyCondition, register) {
  return toString(addName(register, keyCondition.pk.name)) + ` = ` + toString$1(addValue(register, keyCondition.pk.value)) + skConditionToString(keyCondition.sk, register);
}

let KeyCondition = {
  equals: equals$1,
  notEquals: notEquals$1,
  lessThan: lessThan$1,
  lessThanOrEqualTo: lessThanOrEqualTo$1,
  greaterThan: greaterThan$1,
  greaterThanOrEqualTo: greaterThanOrEqualTo$1,
  between: between$1,
  beginsWith: beginsWith$1,
  any: "Any",
  build: build$2
};

function listAppend(identifier, operand) {
  return {
    TAG: "ListAppend",
    identifier: identifier,
    operand: operand
  };
}

function ifNotExists(identifier, operand) {
  return {
    TAG: "IfNotExists",
    identifier: identifier,
    operand: operand
  };
}

function sum(lhs, rhs) {
  return {
    TAG: "Sum",
    lhs: lhs,
    rhs: rhs
  };
}

function sub(lhs, rhs) {
  return {
    TAG: "Sub",
    lhs: lhs,
    rhs: rhs
  };
}

function operandToString(operand, register) {
  switch (operand.TAG) {
    case "AttributePath" :
      return toString$2(addPath(register, {
        TAG: "AttributePath",
        name: operand.name,
        subpath: operand.subpath
      }));
    case "AttributeName" :
      return toString(addName(register, {
        TAG: "AttributeName",
        name: operand.name
      }));
    case "AttributeValue" :
      return toString$1(addValue(register, {
        TAG: "AttributeValue",
        value: operand.value,
        alias: operand.alias
      }));
    case "ListAppend" :
      return `list_append(` + operandToString(operand.identifier, register) + `, ` + operandToString(operand.operand, register) + `)`;
    case "IfNotExists" :
      return `if_not_exists(` + operandToString(operand.identifier, register) + `, ` + operandToString(operand.operand, register) + `)`;
    case "Sum" :
      return operandToString(operand.lhs, register) + ` + ` + operandToString(operand.rhs, register);
    case "Sub" :
      return operandToString(operand.lhs, register) + ` - ` + operandToString(operand.rhs, register);
  }
}

function appendIfNotEmpty(acc, arr, tag, fn) {
  if (arr !== undefined && arr.length !== 0) {
    return acc + tag + " " + arr.map(fn).join(", ") + " ";
  } else {
    return acc;
  }
}

function build$3(update, register) {
  return appendIfNotEmpty(appendIfNotEmpty(appendIfNotEmpty(appendIfNotEmpty("", update.add, "ADD", param => toString$3(param[0], register) + " " + toString$1(addValue(register, param[1]))), update.delete, "DELETE", param => toString$3(param[0], register) + " " + toString$1(addValue(register, param[1]))), update.set, "SET", param => toString$3(param[0], register) + ` = ` + operandToString(param[1], register)), update.remove, "REMOVE", __x => toString$3(__x, register)).trim();
}

let Update = {
  listAppend: listAppend,
  ifNotExists: ifNotExists,
  sum: sum,
  sub: sub,
  build: build$3
};

let U = {
  listAppend: listAppend,
  ifNotExists: ifNotExists,
  sum: sum,
  sub: sub,
  build: build$3
};

let C = {
  equals: equals,
  notEquals: notEquals,
  lessThan: lessThan,
  lessThanOrEqualTo: lessThanOrEqualTo,
  greaterThan: greaterThan,
  greaterThanOrEqualTo: greaterThanOrEqualTo,
  between: between,
  inList: inList,
  attributeExists: attributeExists,
  attributeNotExists: attributeNotExists,
  attributeType: attributeType,
  beginsWith: beginsWith,
  contains: contains,
  toContains: toContains,
  and: and,
  or: or,
  not: not,
  size: size,
  Overload: Overload,
  build: build
};

let K = {
  equals: equals$1,
  notEquals: notEquals$1,
  lessThan: lessThan$1,
  lessThanOrEqualTo: lessThanOrEqualTo$1,
  greaterThan: greaterThan$1,
  greaterThanOrEqualTo: greaterThanOrEqualTo$1,
  between: between$1,
  beginsWith: beginsWith$1,
  any: "Any",
  build: build$2
};

let P = {
  build: build$1
};

exports.AttributeName = AttributeName;
exports.AttributeValue = AttributeValue;
exports.AttributePath = AttributePath;
exports.Register = Register;
exports.Identifier = Identifier;
exports.Condition = Condition;
exports.Projection = Projection;
exports.KeyCondition = KeyCondition;
exports.Update = Update;
exports.U = U;
exports.C = C;
exports.K = K;
exports.P = P;
/* No side effect */
